<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>No Born Talent | No Born Talent</title><meta name="author" content="李泽宇"><meta name="copyright" content="李泽宇"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第一章 网络数据采集概述第二节 网络爬虫概述1.2.1 网络爬虫的基本概念和工作原理网络爬虫的构成部分 需要爬取的网页地址 执行爬取策略的任务调度器 访问页面或下载数据的下载器 分析和提取页面内容的解析器 保存爬得数据结果的存储器  1.2.2 网络爬虫的需求分析网络爬虫的分类根据网络爬虫程序功能和目标的不同，网络爬虫程序可分为：通用爬虫和主题爬虫（或称聚焦爬虫）两类 12通用爬虫：指不针对某个特">
<meta property="og:type" content="article">
<meta property="og:title" content="No Born Talent">
<meta property="og:url" content="http://lzyublog.top/2021/09/23/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/index.html">
<meta property="og:site_name" content="No Born Talent">
<meta property="og:description" content="第一章 网络数据采集概述第二节 网络爬虫概述1.2.1 网络爬虫的基本概念和工作原理网络爬虫的构成部分 需要爬取的网页地址 执行爬取策略的任务调度器 访问页面或下载数据的下载器 分析和提取页面内容的解析器 保存爬得数据结果的存储器  1.2.2 网络爬虫的需求分析网络爬虫的分类根据网络爬虫程序功能和目标的不同，网络爬虫程序可分为：通用爬虫和主题爬虫（或称聚焦爬虫）两类 12通用爬虫：指不针对某个特">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2021-09-23T08:09:51.668Z">
<meta property="article:modified_time" content="2021-11-11T12:57:19.378Z">
<meta property="article:author" content="李泽宇">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><div class="dengl"><div class="d-box"><div class="d1"><span></span><span><p></p></span><ul><li></li><li> </li><li><span></span></li><li> </li><li> </li></ul></div><div class="d2"><span></span><span><p></p></span><ul><li></li><li> </li><li><span></span></li><li> </li><li> </li></ul></div></div><div class="d-box1"><div class="d1"><span></span><span><p></p></span><ul><li></li><li> </li><li><span></span></li><li> </li><li> </li></ul></div><div class="d2"><span></span><span><p></p></span><ul><li></li><li> </li><li><span></span></li><li> </li><li>  </li></ul></div></div></div><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://lzyublog.top/2021/09/23/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'No Born Talent',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-11-11 20:57:19'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="http://lzyublog.top/css/lantern.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/ava.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a></div></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">No Born Talent</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-09-23T08:09:51.668Z" title="发表于 2021-09-23 16:09:51">2021-09-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-11-11T12:57:19.378Z" title="更新于 2021-11-11 20:57:19">2021-11-11</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="第一章-网络数据采集概述"><a href="#第一章-网络数据采集概述" class="headerlink" title="第一章 网络数据采集概述"></a>第一章 网络数据采集概述</h1><h2 id="第二节-网络爬虫概述"><a href="#第二节-网络爬虫概述" class="headerlink" title="第二节 网络爬虫概述"></a>第二节 网络爬虫概述</h2><h3 id="1-2-1-网络爬虫的基本概念和工作原理"><a href="#1-2-1-网络爬虫的基本概念和工作原理" class="headerlink" title="1.2.1 网络爬虫的基本概念和工作原理"></a>1.2.1 网络爬虫的基本概念和工作原理</h3><h4 id="网络爬虫的构成部分"><a href="#网络爬虫的构成部分" class="headerlink" title="网络爬虫的构成部分"></a>网络爬虫的构成部分</h4><ul>
<li>需要爬取的网页地址</li>
<li>执行爬取策略的任务调度器</li>
<li>访问页面或下载数据的下载器</li>
<li>分析和提取页面内容的解析器</li>
<li>保存爬得数据结果的存储器</li>
</ul>
<h3 id="1-2-2-网络爬虫的需求分析"><a href="#1-2-2-网络爬虫的需求分析" class="headerlink" title="1.2.2 网络爬虫的需求分析"></a>1.2.2 网络爬虫的需求分析</h3><h4 id="网络爬虫的分类"><a href="#网络爬虫的分类" class="headerlink" title="网络爬虫的分类"></a>网络爬虫的分类</h4><p>根据网络爬虫程序功能和目标的不同，网络爬虫程序可分为：通用爬虫和主题爬虫（或称聚焦爬虫）两类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通用爬虫：</span><br><span class="line">指不针对某个特定主题，在网络上广泛收集网络链接和网页内容的爬虫，google或baidu搜索引擎中就集成着这类爬虫程序。它们的目标是形成互联网规模的网站地图。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主题爬虫：</span><br><span class="line">是自定义的、面向特定用户需求的网络爬虫程序。与通用爬虫相比，主题爬虫仅爬取用户指定的少量网页，重中提取与主题相关的网页内容，其返回结果也更加定制化，这将有利于用户进行后续的数据分析。</span><br></pre></td></tr></table></figure>
<h4 id="网络爬虫的需求分析"><a href="#网络爬虫的需求分析" class="headerlink" title="网络爬虫的需求分析"></a>网络爬虫的需求分析</h4><h5 id="功能需求"><a href="#功能需求" class="headerlink" title="功能需求"></a>功能需求</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">首先，网络爬虫应当像浏览器一样，能够向网站服务器发出请求，获得web网页。</span><br><span class="line">其次，爬虫程序应当能够将web网页中有关主题的信息进行定位，然后提取出来。</span><br><span class="line">第三，爬虫程序应当能够将提取出的信息进行组织，有序存储到文件或数据库中。</span><br><span class="line">第四，爬虫程序应当能够发现新的与主题相关的网页，自动完成进一步的主题爬取。</span><br></pre></td></tr></table></figure>
<h5 id="性能需求"><a href="#性能需求" class="headerlink" title="性能需求"></a>性能需求</h5><p>根据赛义德等人的研究，衡量网络爬虫程序性能的指标有很多。</p>
<p>比如：覆盖度、新鲜度、礼貌性、陷阱绕过能力、扩展性、时效性、提交效率、状态敏感度等。</p>
<ul>
<li><p>覆盖度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">指的是网络爬虫程序已访问的网页数量与所需访问的网页数量的比值。</span><br><span class="line">相当于查全率，体现了网路爬虫能否自动跟踪所有主题相关网页，完整爬取兴趣内容的能力。</span><br></pre></td></tr></table></figure>
</li>
<li><p>新鲜度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">指的是当前时间和爬虫程序最新爬得内容时间的差值。差值越小，内容越新鲜。</span><br><span class="line">新鲜度反映了网络爬虫程序及时发现和获取最新发布内容的能力。</span><br></pre></td></tr></table></figure>
</li>
<li><p>时效性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指网络爬虫程序完成一次有效爬取所耗费的时间。</span><br></pre></td></tr></table></figure>
</li>
<li><p>礼貌性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">反映了爬虫程序对服务器访问压力的大小。</span><br><span class="line">在设计爬虫程序时，应当避免对服务器进行密集访问。</span><br></pre></td></tr></table></figure>
</li>
<li><p>陷阱绕过能力</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指网络爬虫程序自动识别	重复链接、避开爬虫陷阱的能力</span><br></pre></td></tr></table></figure>
</li>
<li><p>扩展性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指的是爬虫程序爬取和下载数据量的大小。</span><br></pre></td></tr></table></figure>
</li>
<li><p>提交效率</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">衡量爬虫成功提交web页面表单的能力</span><br></pre></td></tr></table></figure>
</li>
<li><p>状态敏感度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">反应爬虫程序正确感知网页DOM状态更新的能力</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="第二章-网络爬取相关的Web技术"><a href="#第二章-网络爬取相关的Web技术" class="headerlink" title="第二章 网络爬取相关的Web技术"></a>第二章 网络爬取相关的Web技术</h1><h2 id="第一节-网络爬取相关的Web技术"><a href="#第一节-网络爬取相关的Web技术" class="headerlink" title="第一节 网络爬取相关的Web技术"></a>第一节 网络爬取相关的Web技术</h2><h3 id="相关web技术概述"><a href="#相关web技术概述" class="headerlink" title="相关web技术概述"></a>相关web技术概述</h3><blockquote>
<p>Web是一种基于HTML和HTTP的全球性的分布式图形信息系统，它是一种建立在Internet上的一种网络服务。</p>
</blockquote>
<h3 id="2-1-1-构成web的五大要素"><a href="#2-1-1-构成web的五大要素" class="headerlink" title="2.1.1 构成web的五大要素"></a>2.1.1 构成web的五大要素</h3><ol>
<li>web页面的统一资源定位符（URL）</li>
<li>超文本传输协议（HTTP）</li>
<li>超文本标记语言（HTML）</li>
<li>Web服务器</li>
<li>Web浏览器</li>
</ol>
<blockquote>
<p> 网络爬虫实际上模拟了人浏览网页的过程</p>
</blockquote>
<h3 id="2-1-2-网络爬取的入口-URL"><a href="#2-1-2-网络爬取的入口-URL" class="headerlink" title="2.1.2 网络爬取的入口(URL)"></a>2.1.2 网络爬取的入口(URL)</h3><p>网络爬虫根据人们指定的URL，去访问web页面</p>
<p>URL具有唯一性和和通用性。</p>
<p>唯一性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">互联网上的每个文件都有一个唯一的URL</span><br></pre></td></tr></table></figure>
<p>通用性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URL的构成遵循一定的格式</span><br></pre></td></tr></table></figure>
<h4 id="URL的格式"><a href="#URL的格式" class="headerlink" title="URL的格式"></a>URL的格式</h4><p>URL的格式分为七个部分：</p>
<ol>
<li><p>访问模式（或称通信协议）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">指示服务器采用哪种协议或应用服务，来接受来自客户端的请求，并给予相应。</span><br><span class="line">如:（协议后跟&quot;:\\&quot;作为间隔符）</span><br><span class="line">https://</span><br><span class="line">ftp://</span><br></pre></td></tr></table></figure>
</li>
<li><p>用户信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不是必填项。但若服务器只对授权用户开放，那么就必填。用户信息后跟&quot;@&quot;符号作为间隔符。</span><br></pre></td></tr></table></figure>
</li>
<li><p>主机名称（或IP地址）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">即web网页所在服务器的域名或是IP地址。</span><br><span class="line">域名是一串由点分割的名字组成的Internet上某一台计算机或计算机组的名称。</span><br><span class="line">IP地址是Internet主机的作为路由寻址的数字体标识。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>访问端口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">服务器上某个正在运行的网络服务程序的访问地址。</span><br><span class="line">端口号以整数形式标识，范围为0-65535。</span><br><span class="line">端口号在URL中也不是必填项。缺省时使用访问模式的默认端口。</span><br><span class="line">http的默认端口为80</span><br></pre></td></tr></table></figure>
</li>
<li><p>路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">路径由1个或多个&quot;/&quot;符号隔开的字符串组成，一般用来表示主机上的一个web访问目录或具体的文件路径。</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查询常用于网站服务器传递参数，查询通常由?开始，查询参数使用参数名=参数值的格式，有多个参数时，中间用%(and)符号隔开。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>片段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通常以一个#号开启，用于辅助定位。指定文档中的标签id，用于定位一篇文档中的某个章节</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="URL分为绝对与相对"><a href="#URL分为绝对与相对" class="headerlink" title="URL分为绝对与相对"></a>URL分为绝对与相对</h4><ul>
<li><p>绝对URL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">显示文件的完整路径，访问URL指向的目标时，不用考虑当前程序文件的位置。</span><br></pre></td></tr></table></figure>
</li>
<li><p>相对URL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以包含URL的程序文件位置为参考点，描述目标的位置。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="第二节-网页下载的原理"><a href="#第二节-网页下载的原理" class="headerlink" title="第二节 网页下载的原理"></a>第二节 网页下载的原理</h2><h3 id="2-2-1-超文本传输协议"><a href="#2-2-1-超文本传输协议" class="headerlink" title="2.2.1 超文本传输协议"></a>2.2.1 超文本传输协议</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">是因特网上应用最为广泛的一种网络传输协议，所有的www文件都必须遵循这个标准。</span><br><span class="line">HTTP基于TCP协议，可以进行HTML文件、图片、音频、视频的传输</span><br></pre></td></tr></table></figure>
<h4 id="HTTP的工作原理"><a href="#HTTP的工作原理" class="headerlink" title="HTTP的工作原理"></a>HTTP的工作原理</h4><p>HTTP由请求和响应构成，采用客户端-服务器模式工作。</p>
<p>具体的工作过程</p>
<ol>
<li>用户输入URL，客户端程序在完成域名解析后，获得服务器IP地址；</li>
<li>通过服务器上操作系统提供的TCP/IP协议栈程序，与服务器建立TCP连接（TCP的三次握手）；</li>
<li>TCP连接建立后，客户端程序将HTTP请求封装为HTTP数据包，再封装为TCP数据包，发往服务器；</li>
<li>服务器接收HTTP请求后，根据请求内容进行响应，响应数据也封装为HTTP数据包，然后再封装为TCP数据包，回复给客户端；</li>
<li>服务器关闭这次TCP连接。等待新的请求。</li>
</ol>
<p>三点注意事项</p>
<ol>
<li><p>HTTP是无连接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。</span><br></pre></td></tr></table></figure>
</li>
<li><p>HTTP是媒体独立的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端以及服务器指定使用适合的多用途互联网邮件扩展类型（MIME-type内容类型）。</span><br></pre></td></tr></table></figure>
</li>
<li><p>HTTP是无状态协议</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无状态是指协议对于事物处理没有记忆能力。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="HTTP请求结构"><a href="#HTTP请求结构" class="headerlink" title="HTTP请求结构"></a>HTTP请求结构</h4><ol>
<li><p>请求行     2. 请求头部     3. 空行     4.请求数据</p>
<p><img src="C:\Users\lizeyu\AppData\Roaming\Typora\typora-user-images\image-20210715130555421.png" alt="image-20210715130555421"></p>
</li>
</ol>
<h4 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h4><h5 id="HTTP1-0定义了三种请求方法："><a href="#HTTP1-0定义了三种请求方法：" class="headerlink" title="HTTP1.0定义了三种请求方法："></a>HTTP1.0定义了三种请求方法：</h5><ol>
<li><p>GET</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用于请求指定的页面信息，并返回实体主体。是最为常见的HTTP请求方法。</span><br></pre></td></tr></table></figure>
</li>
<li><p>POST</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">向指定资源提交数据进行处理请求。</span><br><span class="line">数据被包含在请求体中。</span><br><span class="line">POST请求可能会导致新的资源的建立和/或已有资源的修改。</span><br></pre></td></tr></table></figure>
</li>
<li><p>HEAD方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类似于GET请求，只不过返回的响应中没有具体内容，用于获取报头。</span><br><span class="line">常用于测试链接。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="HTTP1-1新增了5种请求方法："><a href="#HTTP1-1新增了5种请求方法：" class="headerlink" title="HTTP1.1新增了5种请求方法："></a>HTTP1.1新增了5种请求方法：</h5><ol>
<li><p>PUT</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从客户端向服务器传送数据，取代指定文档的内容，类似于更新操作。</span><br></pre></td></tr></table></figure>
</li>
<li><p>DELETE</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用于请求服务器删除URL指定的资源。</span><br></pre></td></tr></table></figure>
</li>
<li><p>OPTIONS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用于客户端查看服务器性能参数。</span><br></pre></td></tr></table></figure>
</li>
<li><p>TRACE</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用于会显服务器收到的请求，主要用于测试或诊断。</span><br></pre></td></tr></table></figure>
</li>
<li><p>CONNECT</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="请求头部的参数内容"><a href="#请求头部的参数内容" class="headerlink" title="请求头部的参数内容"></a>请求头部的参数内容</h4><ol>
<li><p>Accept参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用于向服务器申明客户端（浏览器）可以接收的媒体类型（MIME）的资源。</span><br><span class="line">常见赋值：</span><br><span class="line">text/html、application/xhtml+xml、application/xml类型表示客户端允许接收文本、HTML文件、XML文件等，可使用通配符*/*。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Accept-encoding参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">向服务器申明客户端允许接收的压缩编码算法。</span><br><span class="line">常见赋值：</span><br><span class="line">gzip,deflate,br……</span><br></pre></td></tr></table></figure>
</li>
<li><p>Accept-language参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用于向服务器申明客户端允许接收的语言。</span><br><span class="line">常见赋值：</span><br><span class="line">en-US,en和zh-CN等。</span><br><span class="line">q，取值范围为0-1，含义为权重，en-US权重最高，为1，中文网站一般会将zh的权重q设置为0.9。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Cache-control参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">用于控制客户端缓存。</span><br><span class="line">常见赋值：</span><br><span class="line">private、no cache、max-age、must-revalidate.</span><br><span class="line">默认值为private,即由浏览器自身决定缓存大小。</span><br><span class="line">例如：Cache-control:max-age=5</span><br><span class="line">表示访问网页后5s内再次访问该网页不会丢失服务器。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Connection参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用于设置浏览器是否需要与服务器持久连接。</span><br><span class="line">常见取值：</span><br><span class="line">keep-alive和no;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Cookie参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">网站服务器为了判别用户身份、进行会话跟踪而存储在用户本地终端上的数据（通常经过加密）。</span><br><span class="line">在HTTP请求头中设置这个参数，在向服务器发送请求时，就会将保存在该参数下的cookie值发送给web服务器，服务器根据这些值可以获取用户信息和访问历史。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Host参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用于指定请求发往的服务器的域名和端口号。</span><br><span class="line">例www.baidu.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>upgrade-insecure-Requests参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">被赋值为1时，用于声明浏览器支持从http请求自动升级为https请求，并且在以后发送请求时都使用https.</span><br></pre></td></tr></table></figure>
</li>
<li><p>User-Agent参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用于向服务器发送浏览器的版本、系统、应用程序的信息。</span><br><span class="line">常见赋值：</span><br><span class="line">Mozilla/5.0 (Windows NT 10.0;WOW64)、AppleWebKit/537.36 (KHTML, like Gecko)、Chrome/72.0.3626.121、Safari/537.36</span><br></pre></td></tr></table></figure>
</li>
<li><p>Refer参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户告诉服务器，客户端是通过哪一个页面跟踪到当前页面的。即客户端访问页面的上一页面地址</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h4><h4 id="HTTP响应结构"><a href="#HTTP响应结构" class="headerlink" title="HTTP响应结构"></a>HTTP响应结构</h4><ol>
<li>状态行  2. 消息报头 3. 空行 4. 响应正文</li>
</ol>
<h4 id="HTTP响应状态码"><a href="#HTTP响应状态码" class="headerlink" title="HTTP响应状态码"></a>HTTP响应状态码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">也成为HTTP Status Code, 它指示了当前网络的访问状态。</span><br><span class="line">HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。</span><br><span class="line">HTTP响应状态码共分为5种类型</span><br><span class="line">从100到199：响应类型为“信息”，即服务器收到请求，提示客户端继续执行某项操作；</span><br><span class="line">从200到299：响应类型为“成功”，即客户端请求被服务器成功接收并处理；</span><br><span class="line">从300到399：响应类型为“重定向”，表示客户端请求需要进一步的操作以完成请求；</span><br><span class="line">从400到499：响应类型为“客户端错误”，表示请求包含语法错误或无法完成请求；</span><br><span class="line">从500到599：响应类型为“服务器错误”，表示服务器在处理请求的过程中发生了错误。</span><br><span class="line"></span><br><span class="line">状态码100：</span><br><span class="line">表示继续。客户端应继续其请求。</span><br><span class="line">状态码101：</span><br><span class="line">表示切换协议。服务器根据客户端的请求切换协议。</span><br><span class="line"></span><br><span class="line">状态码200：</span><br><span class="line">表示请求成功。一般用于GET与POST请求的响应。</span><br><span class="line">状态码201：</span><br><span class="line">表示已创建。请求成功并创建了新的资源。</span><br><span class="line">状态码202：</span><br><span class="line">表示已接受。即服务器已经接受请求，但未处理完成。</span><br><span class="line"></span><br><span class="line">状态码301：</span><br><span class="line">表示永久移动。请求的资源已被永久地移动到新URL，返回信息会包含新的URL，浏览器会自动定向到新URL。今后任何请求都用新URL代替。	</span><br><span class="line">状态码302：</span><br><span class="line">表示临时移动。与301类似。客户端应继续使用原URL。</span><br><span class="line"></span><br><span class="line">状态码400：</span><br><span class="line">表示客户端请求的语法错误。服务器无法理解。</span><br><span class="line">状态码401：</span><br><span class="line">表示请求要求用户的身份确认。</span><br><span class="line">状态码403：</span><br><span class="line">表示服务器理解客户端的请求，但是拒绝执行此请求。</span><br><span class="line">状态码404：</span><br><span class="line">表示服务器无法根据客户端的请求找到资源（网页）。</span><br><span class="line"></span><br><span class="line">状态码500：</span><br><span class="line">表示服务器内部错误，无法完成请求。</span><br><span class="line">状态码501：</span><br><span class="line">表示服务器不支持请求的功能，无法完成请求。</span><br><span class="line">状态码502：</span><br><span class="line">表示作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应。</span><br><span class="line"></span><br><span class="line">																						——RFC7230手册</span><br></pre></td></tr></table></figure>
<h5 id="响应头部的参数内容"><a href="#响应头部的参数内容" class="headerlink" title="响应头部的参数内容"></a>响应头部的参数内容</h5><ol>
<li><p>Access-Control-Allow-Origin参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用于指定哪些网站可以跨域资源共享。</span><br><span class="line">常见取值：*，表示允许所有网站跨域共享。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Accept-Patch参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用于指定服务器所支持的文档补丁格式。</span><br><span class="line">例如取值：text/example;charset-utf-8 表示支持文本，编码格式为utf-8。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Accept-Ranges参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表示服务器所支持的内容范围。常见取值为bytes。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Age参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表示响应对象在代理缓存中存在的时间。以秒为单位。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Allow参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用于指定对于特定资源的有效动作。常见取值有GET,HEAD等方法。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Cache-Control参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用于通知从服务器到客户端内的所有缓存机制，表示它们是否可以缓存这个对象及缓存有效时间。以秒为单位。</span><br><span class="line">设置值为max-age=3600,表示缓存有效时间为1小时。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Content-Disposition参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表示对已知MIME类型资源的描述，浏览器可以根据这个响应头决定对返回资源的动作。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Content-Encoding参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表示响应资源所使用的编码类型。常见取值为gzip。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Last-Modified参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表示所请求对象的最后修改日期。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Set-cookie参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用于设置HTTP cookie值。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Date参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用于指明响应发送时的日期和时间。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Expires参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用于指定一个日期/时间，超过该时间则认为此响应已经过期。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Server参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用于指定服务器名称</span><br></pre></td></tr></table></figure>
</li>
<li><p>Transfer-Encoding参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表示实体传输给用户的编码形式。                                                             ——RFC2612、RFC7230</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="第三节-内容解析的对象"><a href="#第三节-内容解析的对象" class="headerlink" title="第三节 内容解析的对象"></a>第三节 内容解析的对象</h2><p><script>标签<br>用于定于客户端脚本，比如JavaScripte。script元素即可包含脚本语句，也可通过src属性指向外部脚本文件。<br>JavaScript最常用于图片操作、表单验证已经内容动态更新。</p>
<h2 id="第四节-存储数据的仓库"><a href="#第四节-存储数据的仓库" class="headerlink" title="第四节 存储数据的仓库"></a>第四节 存储数据的仓库</h2><h3 id="2-4-1-文本文件存储数据"><a href="#2-4-1-文本文件存储数据" class="headerlink" title="2.4.1  文本文件存储数据"></a>2.4.1  文本文件存储数据</h3><ul>
<li>纯文本文件，缺少格式控制，也被称为无结构文本，机器可读性较差。</li>
<li>csv文件，全称为逗号分隔符文件。</li>
<li>xml文件，被设计用来在互联网上传输和存储数据。xml的标签是自定义的。</li>
</ul>
<p><img src="C:\Users\lizeyu\AppData\Roaming\Typora\typora-user-images\image-20210719212638479.png" alt="image-20210719212638479"></p>
<ul>
<li>Json文件，是另一种文本文件。它使用JavaScript对象标识法来组织数据。轻量级</li>
</ul>
<p><img src="C:\Users\lizeyu\AppData\Roaming\Typora\typora-user-images\image-20210719212945236.png" alt="image-20210719212945236"></p>
<ul>
<li><p>YAML文件，另一种文本文件。YAML的开发者认为YAML是一种对人类友好可读的，面向所有编程语言的数据序列化标准。</p>
<p>使用空白字符和分行来分割信息，适合用来表达节层式的数据结构，也可以表示关联性。常用作应用程序的配置文件。</p>
</li>
</ul>
<p><img src="C:\Users\lizeyu\AppData\Roaming\Typora\typora-user-images\image-20210719213333714.png" alt="image-20210719213333714"></p>
<h3 id="2-4-2-数据库管理系统"><a href="#2-4-2-数据库管理系统" class="headerlink" title="2.4.2  数据库管理系统"></a>2.4.2  数据库管理系统</h3><ul>
<li>关系型数据库是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。</li>
</ul>
<blockquote>
<p>关系模型</p>
<p>Atomic 原子性</p>
<p>Consistency 一致性</p>
<p>Isolation 隔离性</p>
<p>Durability 持久性</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">关系型数据库的优点：容易理解、使用方便、易于维护等等。</span><br><span class="line">关系型数据库的问题：关系型数据库存放在硬盘上，当访问量非常大时，磁盘I/O是性能瓶颈。关系型数据库的大表查询能力、多表关联能力，复杂SQL查询的效率较低，它的扩展性较差，不能简单通过添加更多的硬件和服务节点来扩展性能和负载能力。</span><br></pre></td></tr></table></figure>
<ul>
<li>非关系型数据库指非关系型的，分布式的，且一般不保证遵循ACID原则的数据存储系统。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">非关系型数据库以键值对方式存储，且结构不固定，每一个元组可以有不一样的字段，每个元组可以根据自己的需要增加一些键值对，不局限于固定的结构，可减少时间和空间的开销.</span><br><span class="line"></span><br><span class="line">非关系型数据库的优点：易于扩展、适应大数据量查询，性能较高，具有灵活的数据模型，用户可以随时自定义数据格式，在不影响性能的情况下，可以方便实现高可用架构。</span><br><span class="line">非关系型数据库的缺点：没有标准、没有数据模型、不支持SQL语句，NoSQL数据库没有标准的查询语言，因此进行数据库查询需要制定数据模型。</span><br></pre></td></tr></table></figure>
<p><strong>NoSQL数据库产品</strong></p>
<ul>
<li><p>键值存储数据库</p>
<blockquote>
<p>主要会使用到哈希表，在这个表中有一个特定的键和一个指针指向特定的数据。</p>
</blockquote>
</li>
<li><p>列存储数据库</p>
<blockquote>
<p>这部分数据库通常是用来应对分布式存储的海量数据。</p>
</blockquote>
</li>
<li><p>文档型数据库</p>
<blockquote>
<p>键值嵌套</p>
</blockquote>
</li>
<li><p>图形数据库</p>
<blockquote>
<p>图形结构的数据库同其他行列以及刚性结构的SQL数据库不同，它是使用灵活的图形模型，并且能够扩展到多个服务器上。</p>
</blockquote>
</li>
</ul>
<h1 id="第三章-爬取web页面的基本过程"><a href="#第三章-爬取web页面的基本过程" class="headerlink" title="第三章  爬取web页面的基本过程"></a>第三章  爬取web页面的基本过程</h1><h2 id="第一节-爬取web页面的基本过程"><a href="#第一节-爬取web页面的基本过程" class="headerlink" title="第一节  爬取web页面的基本过程"></a>第一节  爬取web页面的基本过程</h2><p><img src="C:\Users\lizeyu\AppData\Roaming\Typora\typora-user-images\image-20210719224056947.png" alt="image-20210719224056947"></p>
<ol>
<li>人工确定待爬取的目标网页的URL，并将这个URL放入待爬取队列。</li>
<li>网络爬虫程序能够像浏览器一样，根据输入的URL向远程服务器发出HTTP请求，尝试获得响应内容，通常是目标数据所在的HTML文件。</li>
<li>网络爬虫程序能够解析已下载HTML文档内容。检索HTML文档，提取出目标数据的过程。除了目标数据，可能还需要获得新的URL，为后续爬取提供种子。</li>
<li>网络爬虫程序需要将提取出的数据，按照用户所需的个数存储下来。使用某种格式的文件或数据库来存储数据，将需要的图片或视频资源下载到特定的文件夹中，而爬得的新URL将放入带爬取队列中。</li>
<li>网络爬虫程序将按上述步骤，逐一处理待爬取队列中的URL，直到队列为空。</li>
</ol>
<h2 id="第二节-使用Urllib实现基本web页面爬取"><a href="#第二节-使用Urllib实现基本web页面爬取" class="headerlink" title="第二节  使用Urllib实现基本web页面爬取"></a>第二节  使用Urllib实现基本web页面爬取</h2><h3 id="3-2-1-使用Urllib实现基本web页面爬取"><a href="#3-2-1-使用Urllib实现基本web页面爬取" class="headerlink" title="3.2.1  使用Urllib实现基本web页面爬取"></a>3.2.1  使用Urllib实现基本web页面爬取</h3><p>urllib库</p>
<ol>
<li>访问URL   </li>
<li>传递参数</li>
<li>设置代理</li>
<li>进行身份认证</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">anoconda安装</span><br><span class="line"></span><br><span class="line">Urllib库</span><br><span class="line">第一模块urllib.request</span><br><span class="line">用于打开和读取URL 处理简单或摘要类型的页面认证，页面重定向、已经cookie等访问web页面时的常见问题。</span><br><span class="line">第二模块urllib.error</span><br><span class="line">request模块可能引发的异常</span><br><span class="line">第三模块urllib.parse</span><br><span class="line">解析URL</span><br><span class="line">第四模块urllib.rebotparser</span><br><span class="line">解析robots.txt文件</span><br></pre></td></tr></table></figure>
<p>Request库的主要特点：</p>
<ul>
<li>能够自动保持与网站的TCP连接</li>
<li>能够内含带持久cookie的会话机制</li>
<li>能够提供像浏览器类似的SSL认证</li>
<li>能够自动完成内容解码</li>
<li>能够支持文件分块上传和流式下载</li>
<li>能够自动对下载图片、文件进行解压</li>
<li>能够支持Unicode响应结果 ……</li>
</ul>
<p><img src="C:\Users\lizeyu\AppData\Roaming\Typora\typora-user-images\image-20210722235150865.png" alt="image-20210722235150865"></p>
<h1 id="第四章-web页面内容解析"><a href="#第四章-web页面内容解析" class="headerlink" title="第四章  web页面内容解析"></a>第四章  web页面内容解析</h1><h2 id="第一节-如何实现web页面内容的解析"><a href="#第一节-如何实现web页面内容的解析" class="headerlink" title="第一节  如何实现web页面内容的解析"></a>第一节  如何实现web页面内容的解析</h2><p>详情查看  ppt</p>
<h2 id="第二节-文本内容的解析"><a href="#第二节-文本内容的解析" class="headerlink" title="第二节  文本内容的解析"></a>第二节  文本内容的解析</h2><p>使用正则表达式来解析文本内容。</p>
<blockquote>
<p>正则表达式：又称规则表达式，通常用来检索、替换那些符合某个模式（规则）的文本。</p>
<p>是对字符串操作的一种逻辑公式，用实现定义好的一些特定字符、及这些特定字符的组合，组成一个规则字符串，这个规则字符串用来表达对字符串的一种过滤逻辑。</p>
</blockquote>
<p><img src="C:\Users\lizeyu\AppData\Roaming\Typora\typora-user-images\image-20210724222051668.png" alt="image-20210724222051668"></p>
<p>python的re模块：包含了正则表达式的各个操作集。</p>
<p>re模块的使用步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第一步：编译正则表达式</span><br><span class="line">	使用compile()函数将正则表达式的字符串形式编译为一个Pattern对象；</span><br><span class="line">第二步：对目标字符串进行匹配</span><br><span class="line">	使用Pattern对象提供的一系列方法对文本进行匹配查找，获得匹配结果（Match对象）；</span><br><span class="line">第三步：提取结果信息</span><br><span class="line">	使用Match对象提供的属性和方法获得信息，还可根据需要进行其他的操作。</span><br></pre></td></tr></table></figure>
<h2 id="第三节-类XML内容的解析"><a href="#第三节-类XML内容的解析" class="headerlink" title="第三节  类XML内容的解析"></a>第三节  类XML内容的解析</h2><p>类XML文档包括HTML，XML等标记语言文档。利用XPATH实现XML和HTML文本信息的提取。</p>
<blockquote>
<p>XPath(XML Path Language)，是一种在XML文档中查找信息的语言，可用来在类XML文档中对元素和属性进行遍历。</p>
<p><strong>XPath通过路径表达式、谓词、通配符、逻辑运算符等语法实例实现信息查找</strong></p>
</blockquote>
<h3 id="4-3-1-XPath-使用路径表达式来选取XML文档中的节点或节点集。"><a href="#4-3-1-XPath-使用路径表达式来选取XML文档中的节点或节点集。" class="headerlink" title="4.3.1  XPath 使用路径表达式来选取XML文档中的节点或节点集。"></a>4.3.1  XPath 使用路径表达式来选取XML文档中的节点或节点集。</h3><div class="table-container">
<table>
<thead>
<tr>
<th>表达式</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>nodename</td>
<td style="text-align:left">选取此节点的所有子节点</td>
</tr>
<tr>
<td>/</td>
<td style="text-align:left">从根节点选取</td>
</tr>
<tr>
<td>//</td>
<td style="text-align:left">从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置</td>
</tr>
<tr>
<td>.</td>
<td style="text-align:left">选取当前节点</td>
</tr>
<tr>
<td>..</td>
<td style="text-align:left">选取当前节点的父节点</td>
</tr>
<tr>
<td>@</td>
<td style="text-align:left">选取属性</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>路径表达式</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>bookstore</td>
<td>选取bookstore元素的所有子节点。</td>
</tr>
<tr>
<td>/bookstore</td>
<td>选取根元素bookstore。注：路径起始于正斜杠(/)，代表绝对路径。</td>
</tr>
<tr>
<td>bookstore/book</td>
<td>选取属于bookstore的子元素的所有book元素。</td>
</tr>
<tr>
<td>//book</td>
<td>选取所有book子元素，而不管它们在文档中的位置。</td>
</tr>
<tr>
<td>bookstore//book</td>
<td>选择属于bookstore元素的后代的所有book元素。</td>
</tr>
<tr>
<td>//@lang</td>
<td>选取名为lang的所有属性。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="4-3-2-谓语"><a href="#4-3-2-谓语" class="headerlink" title="4.3.2  谓语"></a>4.3.2  谓语</h3><p>谓语（Predicates）用来查找某个特定的节点或者包含某个指定的值的节点。谓语被嵌套在方括号中。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>路径表达式</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>/bookstore/book[1]</td>
<td>选取属于 bookstore 子元素的第一个 book 元素。</td>
</tr>
<tr>
<td>/bookstore/book[last()]</td>
<td>选取属于 bookstore 子元素的最后一个 book 元素。</td>
</tr>
<tr>
<td>/bookstore/book[last()]</td>
<td>选取属于 bookstore 子元素的倒数第二个 book 元素。</td>
</tr>
<tr>
<td>/bookstore/book[position()&lt;3]</td>
<td>选取属于 bookstore 子元素前二个 book 元素。</td>
</tr>
<tr>
<td>//title[@lang]</td>
<td>选取所有拥有名为lang的属性的title元素。</td>
</tr>
<tr>
<td>//title[@lang=’eng’]</td>
<td>选取所有拥有名为lang的属性且lang的值为eng的title元素。</td>
</tr>
<tr>
<td>/bookstore/book[price&gt;35.00]</td>
<td>选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于35.00。</td>
</tr>
<tr>
<td>/bookstore/book[price&gt;35.00]/title</td>
<td>选取所有 bookstore 元素中的 book 元素的所有title元素，且其中的price元素值大于35.00</td>
</tr>
</tbody>
</table>
</div>
<p><strong>通过在路径表达式中使用”|”运算符，可以选择多个路径</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>路径表达式</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>//book/title \</td>
<td>//book/price</td>
<td>选取 book 元素的所有 title 元素和 price 元素。</td>
</tr>
<tr>
<td>//title \</td>
<td>//price</td>
<td>选取文档中的所有 title 和 price 元素。</td>
</tr>
<tr>
<td>/bookstore/book/title \</td>
<td>//price</td>
<td>选取属于 bookstore 元素的 book 元素的所有 title 元素，以及文档中的所有 price 元素。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="4-3-3-通配符选取未知的XML元素"><a href="#4-3-3-通配符选取未知的XML元素" class="headerlink" title="4.3.3 通配符选取未知的XML元素"></a>4.3.3 通配符选取未知的XML元素</h3><div class="table-container">
<table>
<thead>
<tr>
<th>通配符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>匹配任何元素节点</td>
</tr>
<tr>
<td>@*</td>
<td>匹配任何属性节点</td>
</tr>
<tr>
<td>node()</td>
<td>匹配任何类型的节点</td>
</tr>
</tbody>
</table>
</div>
<p><img src="C:\Users\lizeyu\AppData\Roaming\Typora\typora-user-images\image-20210726232812554.png" alt="image-20210726232812554"></p>
<h3 id="第四节-解析JSON数据"><a href="#第四节-解析JSON数据" class="headerlink" title="第四节 解析JSON数据"></a>第四节 解析JSON数据</h3><p>JSON数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">是一种轻量级的数据交换格式，目前广泛应用于web编程和数据交换。</span><br><span class="line">简单地说JSON就是javascript中的对象和数组，通过这两种结构可以表示各种复杂的结构。</span><br><span class="line">JSON的详细说明参见w3school的标准教程。</span><br></pre></td></tr></table></figure>
<p>Python中自建了JSON处理模块json</p>
<blockquote>
<p>json模块提供了四种方法，用于将json字符串或json文件于Python对象进行相互转化。</p>
</blockquote>
<ul>
<li><p>json.dumps()</p>
<blockquote>
<p>将python类型转化为json字符串，返回一个str。</p>
</blockquote>
</li>
<li><p>json.dump()</p>
<blockquote>
<p>将python内置类型系列化为json对象后写入文件。</p>
</blockquote>
</li>
<li><p>json.loads()</p>
<blockquote>
<p>将json格式字符串解析为python对象，返回一个python对象。</p>
</blockquote>
</li>
<li><p>json.load()</p>
<blockquote>
<p>读取文件中json形式的字符串元素，转化为python类型。</p>
</blockquote>
</li>
</ul>
<p>JsonPath是一种信息抽取类库，从json文档中抽取指定信息的工具。相当于XPATH对于XML。</p>
<h1 id="第五章-自动跨越身份认证"><a href="#第五章-自动跨越身份认证" class="headerlink" title="第五章  自动跨越身份认证"></a>第五章  自动跨越身份认证</h1><h2 id="第一节-Web身份认证技术概述"><a href="#第一节-Web身份认证技术概述" class="headerlink" title="第一节 Web身份认证技术概述"></a>第一节 Web身份认证技术概述</h2><ol>
<li><p>HTTP基本认证</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP基本认证是一种允许Web浏览器或其他客户端在请求时提供与户名和口令形式的身份凭证的一种登录验证方式。（账号密码认认证机制）</span><br><span class="line">优点：</span><br><span class="line">HTTP基本认证是基本上所有流行的网页浏览器都支持。但是基本认证很少在可公开访问的互联网网站上使用，有时候会在很小的私有系统中使用。</span><br><span class="line">缺点：</span><br><span class="line">若无SSL/LTS传输层安全协议保护，以明文传输的口令和密匙容易被拦截。</span><br></pre></td></tr></table></figure>
</li>
<li><p>OAuth(开放授权)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OAuth是一个开放标准，允许用户让第三方应用访问该用户存储在某一网站上的私密资源，而无需提供用户名和密码。（令牌机制）</span><br><span class="line">特定的时段、特定的资源、</span><br></pre></td></tr></table></figure>
</li>
<li><p>cookie和session认证</p>
</li>
<li><p>Token认证    </p>
</li>
</ol>
<h2 id="第二节-自动跨越http-basic认证"><a href="#第二节-自动跨越http-basic认证" class="headerlink" title="第二节  自动跨越http basic认证"></a>第二节  自动跨越http basic认证</h2><h2 id="第三节-自动跨越http-digest认证"><a href="#第三节-自动跨越http-digest认证" class="headerlink" title="第三节  自动跨越http digest认证"></a>第三节  自动跨越http digest认证</h2><p>http digest 认证不以明文方式在网络上发送密码；可以防止恶意用户捕捉并重放认证的握手过程；可以有选择地防止对报文内容的篡改。</p>
<p><img src="C:\Users\lizeyu\AppData\Roaming\Typora\typora-user-images\image-20210729232311091.png" alt="image-20210729232311091"></p>
<h2 id="第四节-自动跨越OAuth认证"><a href="#第四节-自动跨越OAuth认证" class="headerlink" title="第四节  自动跨越OAuth认证"></a>第四节  自动跨越OAuth认证</h2><p>OAuth认证</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OAuth为用户资源的授权提供了一个简单又安全的标准。</span><br><span class="line">与以往的授权方式不同之处是OAuth的授权不会使第三方触及到用户的账号信息（如用户名和密码），即第三方无需使用用户的用户名和密码，就可以申请获得该用户资源的授权。</span><br><span class="line">可以用于Web应用、移动应用、桌面应用。</span><br></pre></td></tr></table></figure>
<p><img src="C:\Users\lizeyu\AppData\Roaming\Typora\typora-user-images\image-20210731092114617.png" alt="image-20210731092114617"></p>
<p><img src="C:\Users\lizeyu\AppData\Roaming\Typora\typora-user-images\image-20210731092428916.png" alt="image-20210731092428916"></p>
<h1 id="第六章-RIA网站数据的爬取"><a href="#第六章-RIA网站数据的爬取" class="headerlink" title="第六章      RIA网站数据的爬取"></a>第六章      RIA网站数据的爬取</h1><h2 id="第一节-RIA应用的技术构成"><a href="#第一节-RIA应用的技术构成" class="headerlink" title="第一节 RIA应用的技术构成"></a>第一节 RIA应用的技术构成</h2><blockquote>
<p>RIA(Rich Internet Applications),富互联网应用程序，是一种特殊的互联网应用程序，其用户界面比第一代和第二代Web应用程序具有更丰富的功能。</p>
<p>RIA网站通常使用JavaScript、Flash、Google Web Toolkit、JavaFX、Silverlight在浏览器中执行。</p>
<p>目前，HTML5+JavaScript+CSS3+JavaScript Frameworks是构建RIA前端的主流技术。</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">JavaScript框架</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">JQuery</td>
</tr>
<tr>
<td style="text-align:center">AnglarJS</td>
</tr>
<tr>
<td style="text-align:center">D3</td>
</tr>
<tr>
<td style="text-align:center">Sencha EXT-JS</td>
</tr>
<tr>
<td style="text-align:center">SmartClient</td>
</tr>
<tr>
<td style="text-align:center">Dart</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<p>RIA在加载数据时往往采用异步加载XML或JSON实现数据更新，而页面的URL并不改变。</p>
<p>AJAX原理</p>
<blockquote>
<p>AJAX，异步JavaScript和XML，它是一种用于创建快速动态网页的技术。</p>
<p>通过在后台与服务器进行少量的数据交换，AJAX可以使网页实现异步更新。从而在不重载则整个网页的情况下，对网页的某部分及逆行更新。</p>
</blockquote>
<p><img src="C:\Users\lizeyu\AppData\Roaming\Typora\typora-user-images\image-20210731101515266.png" alt="image-20210731101515266"></p>
<ul>
<li><p>浏览器端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户浏览一个RIA页面时，通过鼠标或键盘激发一个JavaScript事件后，浏览器会生成一个XMLHttp Request对象，然后将这个请求对象通过互联网发送给服务器。</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务器端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">服务器收到XMLHttpRequest对象后，会根据请求生成一个响应，并通过网络传递给服务器。</span><br><span class="line">浏览器收到服务器响应后，会使用JavaScript处理反馈数据，然后更新页面内容。</span><br></pre></td></tr></table></figure>
<p>如下代码生成用于异步加载数据的XMLHttpRequest对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlhttp;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest)&#123;</span><br><span class="line">    <span class="comment">//code for IE7+, Firefox, Chrome, Opera, Safari</span></span><br><span class="line">    xmlhttp = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    xml = <span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="C:\Users\lizeyu\AppData\Roaming\Typora\typora-user-images\image-20210731102114591.png" alt="image-20210731102114591"></p>
<p><img src="C:\Users\lizeyu\AppData\Roaming\Typora\typora-user-images\image-20210731102127180.png" alt="image-20210731102127180"></p>
<p>服务器响应内容可以通过XMLHttpRequest对象的responseText或responseXML属性获取。响应内容非XML格式用前者，响应内容以XML格式返回用后者。</p>
<p><img src="C:\Users\lizeyu\AppData\Roaming\Typora\typora-user-images\image-20210731102206004.png" alt="image-20210731102206004"></p>
<p><img src="C:\Users\lizeyu\AppData\Roaming\Typora\typora-user-images\image-20210731102537645.png" alt="image-20210731102537645"></p>
<p><img src="C:\Users\lizeyu\AppData\Roaming\Typora\typora-user-images\image-20210731102555145.png" alt="image-20210731102555145"></p>
<h2 id="第二节-模拟人工操作爬取网站数据"><a href="#第二节-模拟人工操作爬取网站数据" class="headerlink" title="第二节  模拟人工操作爬取网站数据"></a>第二节  模拟人工操作爬取网站数据</h2><p>通过操纵键盘和鼠标，模拟人使用浏览器来出发JavaScript Action, 当页面数据被异步加载后，直接从页面内容中读取所需数据。</p>
<p>为了操纵键盘和鼠标，我们需要借助Selenium库。</p>
<blockquote>
<p>Selenium:</p>
<p>一个Web的自动化测试工具，最初是为网站自动化测试而开发的，类型像我们玩游戏用的按键精灵，可以按指定的命令自动操作。不同的是，Selenium可以直接运行在浏览器上，支持所有主流的浏览器。</p>
<p>Selenium可以根据我们的指令，让浏览器自动加载页面，获取需要的数据，甚至页面截屏，或者判断网站上某些动作是否发生。</p>
<p>Selenium不自带浏览器，需要和浏览器主动结合，但需要事先安装相关的库和程序。</p>
</blockquote>
<h1 id="第七章-构建健壮的爬虫系统"><a href="#第七章-构建健壮的爬虫系统" class="headerlink" title="第七章  构建健壮的爬虫系统"></a>第七章  构建健壮的爬虫系统</h1><h2 id="第一节-Scrapy-爬虫框架基础"><a href="#第一节-Scrapy-爬虫框架基础" class="headerlink" title="第一节  Scrapy 爬虫框架基础"></a>第一节  Scrapy 爬虫框架基础</h2><h3 id="7-1-1-Scrapy爬虫框架的基本组成和工作原理"><a href="#7-1-1-Scrapy爬虫框架的基本组成和工作原理" class="headerlink" title="7.1.1  Scrapy爬虫框架的基本组成和工作原理"></a>7.1.1  Scrapy爬虫框架的基本组成和工作原理</h3><p>Scrapy是一个用于爬取网页、提取结构化数据的应用框架，可用于数据挖掘、信息处理或历史归档等多种应用系统。</p>
<p>Scrapy的主要模块有：</p>
<ol>
<li><p>Scrapy Engine(引擎)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">负责Spider、ItemPipline、Downloader、Scheduler中间的通讯，信号、数据传递……</span><br></pre></td></tr></table></figure>
</li>
<li><p>Scheduler(调度器)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">负责接收引擎发送过来的Request请求，并按照一定的方式进行整理排列，入队，当引擎需要时，交还给引擎。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Downloader(下载器)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">负责下载Scrapy Engine(引擎)发送的所有Request请求，并将其获取到的Responses交还给Scrapy Engine(引擎)，由引擎交给Spider来处理。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Spider(爬虫)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">负责处理所有的Responses，从中分析提取数据，获取Item字段需要的数据，并将需要跟进的URL提交给引擎，再次进入Scheduler(调度器)。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Item Pipeline(管道)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">负责处理Spider中获取到的Item，并进行后期处理（详细分析、过滤、存储等）。</span><br></pre></td></tr></table></figure>
<p>以流水线方式对Spider解析后的结果（Item），用户可以定义一组操作顺序，包括：清理、检验、查重、存储到数据库等。</p>
</li>
<li><p>Downloader Middlewares(下载中间件)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个可自定义扩展下载功能的组件。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Spider Middlewares(Spider中间件)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个可以自定扩展和操作引擎和Spider中间通信功能组件（比如进入Spider的Responses和从Spider出去的Requests）。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="C:\Users\lizeyu\AppData\Roaming\Typora\typora-user-images\image-20210802110029462.png" alt="image-20210802110029462"></p>
<p><img src="C:\Users\lizeyu\AppData\Roaming\Typora\typora-user-images\image-20210802110137651.png" alt="image-20210802110137651"></p>
<p><img src="C:\Users\lizeyu\AppData\Roaming\Typora\typora-user-images\image-20210802110215981.png" alt="image-20210802110215981"></p>
<p><img src="C:\Users\lizeyu\AppData\Roaming\Typora\typora-user-images\image-20210802110323191.png" alt="image-20210802110323191"></p>
<h2 id="第二节-scrapy爬虫框架应用"><a href="#第二节-scrapy爬虫框架应用" class="headerlink" title="第二节  scrapy爬虫框架应用"></a>第二节  scrapy爬虫框架应用</h2><h3 id="7-2-1-组件scrapy爬虫运行环境"><a href="#7-2-1-组件scrapy爬虫运行环境" class="headerlink" title="7.2.1  组件scrapy爬虫运行环境"></a>7.2.1  组件scrapy爬虫运行环境</h3><p><img src="C:\Users\lizeyu\AppData\Roaming\Typora\typora-user-images\image-20210806233145587.png" alt="image-20210806233145587"></p>
<p><img src="C:\Users\lizeyu\AppData\Roaming\Typora\typora-user-images\image-20210806233119834.png" alt="image-20210806233119834"></p>
<h3 id="7-2-2-执行一个scrapy项目案例"><a href="#7-2-2-执行一个scrapy项目案例" class="headerlink" title="7.2.2  执行一个scrapy项目案例"></a>7.2.2  执行一个scrapy项目案例</h3><h1 id="第八章-构建高性能的爬虫系统"><a href="#第八章-构建高性能的爬虫系统" class="headerlink" title="第八章  构建高性能的爬虫系统"></a>第八章  构建高性能的爬虫系统</h1><h2 id="第一节-分布式爬虫系统概述"><a href="#第一节-分布式爬虫系统概述" class="headerlink" title="第一节 分布式爬虫系统概述"></a>第一节 分布式爬虫系统概述</h2><p>第三次数据化浪潮：大数据，云计算，物联网</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">网络上各类信息的产生速度和数据容量不断攀升，传统的爬虫程序在采集速度和存储容量上存在瓶颈，无法满足大数据时代的数据采集要求。</span><br><span class="line">对海量数据的计算和存储，产生了分布式计算和分布式存储。</span><br></pre></td></tr></table></figure>
<p><strong>使用Redis-scrapy模块，扩展scrapy爬虫框架，构建分布式网络爬虫。</strong></p>
<blockquote>
<p>分布式系统：</p>
<p>一组计算机，通过网络相互连接，通信后协调它们的行为而构成的系统。</p>
<p>组件之间相互协调，共同完成一个计算任务。</p>
<p>需要进行大量计算的任务，分割成小块，由多台计算机分别计算存储，再上传数据结果，最终汇合合并成最终的数据结果。</p>
</blockquote>
<p>分布式爬虫系统是用于完成数据采集任务的分布式系统。</p>
<p>根据机器之间的协同方式：可分为主从式分布式爬虫系统和对等式分布式爬虫系统。</p>
<p><img src="C:\Users\lizeyu\AppData\Roaming\Typora\typora-user-images\image-20210808104339496.png" alt="image-20210808104339496"></p>
<p><img src="C:\Users\lizeyu\AppData\Roaming\Typora\typora-user-images\image-20210808104357599.png" alt="image-20210808104357599"></p>
<p><img src="C:\Users\lizeyu\AppData\Roaming\Typora\typora-user-images\image-20210808104430734.png" alt="image-20210808104430734"></p>
<p><img src="C:\Users\lizeyu\AppData\Roaming\Typora\typora-user-images\image-20210808104457802.png" alt="image-20210808104457802"></p>
<p><img src="C:\Users\lizeyu\AppData\Roaming\Typora\typora-user-images\image-20210808104509942.png" alt="image-20210808104509942"></p>
<p><img src="C:\Users\lizeyu\AppData\Roaming\Typora\typora-user-images\image-20210808104605477.png" alt="image-20210808104605477"></p>
<p>在实际构建分布式爬虫系统时，人们常常采用<strong><em>高性能的键值数据库</em></strong>、<strong><em>消息队列</em></strong>和<strong><em>非阻塞I/O调度</em></strong>。</p>
<h2 id="第二节-Redis-Scrapy介绍"><a href="#第二节-Redis-Scrapy介绍" class="headerlink" title="第二节 Redis-Scrapy介绍"></a>第二节 Redis-Scrapy介绍</h2><p>当爬取队列中URL过多时，我们需要多个Schedular从队列中提取URL，同时也需要由多个downloader去访问<strong>指定</strong>的URL。这时就要求队列的I/O性能足够好，才能满足多台服务器中爬虫的读写URL需求。</p>
<p>高性能的内存数据库：Redis</p>
<p><img src="C:\Users\lizeyu\AppData\Roaming\Typora\typora-user-images\image-20210808105246842.png" alt="image-20210808105246842"></p>
<p><img src="C:\Users\lizeyu\AppData\Roaming\Typora\typora-user-images\image-20210808105317463.png" alt="image-20210808105317463"></p>
<p><img src="C:\Users\lizeyu\AppData\Roaming\Typora\typora-user-images\image-20210808105346017.png" alt="image-20210808105346017"></p>
<p><img src="C:\Users\lizeyu\AppData\Roaming\Typora\typora-user-images\image-20210808105519120.png" alt="image-20210808105519120"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">李泽宇</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://lzyublog.top/2021/09/23/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/">http://lzyublog.top/2021/09/23/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://lzyublog.top" target="_blank">No Born Talent</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/09/23/Python%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%92%8C%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Python数据采集和网络爬虫</div></div></a></div><div class="next-post pull-right"><a href="/2021/09/23/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">离散数学</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/ava.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">李泽宇</div><div class="author-info__description">软件定义世界，数据驱动未来。</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">第一章 网络数据采集概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%8A%82-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">第二节 网络爬虫概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.2.1 网络爬虫的基本概念和工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E7%9A%84%E6%9E%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">网络爬虫的构成部分</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E7%9A%84%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2.2 网络爬虫的需求分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">网络爬虫的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E7%9A%84%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">网络爬虫的需求分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E9%9C%80%E6%B1%82"><span class="toc-number">1.1.2.2.1.</span> <span class="toc-text">功能需求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E9%9C%80%E6%B1%82"><span class="toc-number">1.1.2.2.2.</span> <span class="toc-text">性能需求</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%88%AC%E5%8F%96%E7%9B%B8%E5%85%B3%E7%9A%84Web%E6%8A%80%E6%9C%AF"><span class="toc-number">2.</span> <span class="toc-text">第二章 网络爬取相关的Web技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%8A%82-%E7%BD%91%E7%BB%9C%E7%88%AC%E5%8F%96%E7%9B%B8%E5%85%B3%E7%9A%84Web%E6%8A%80%E6%9C%AF"><span class="toc-number">2.1.</span> <span class="toc-text">第一节 网络爬取相关的Web技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3web%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.1.</span> <span class="toc-text">相关web技术概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E6%9E%84%E6%88%90web%E7%9A%84%E4%BA%94%E5%A4%A7%E8%A6%81%E7%B4%A0"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.1.1 构成web的五大要素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E7%BD%91%E7%BB%9C%E7%88%AC%E5%8F%96%E7%9A%84%E5%85%A5%E5%8F%A3-URL"><span class="toc-number">2.1.3.</span> <span class="toc-text">2.1.2 网络爬取的入口(URL)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#URL%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">URL的格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#URL%E5%88%86%E4%B8%BA%E7%BB%9D%E5%AF%B9%E4%B8%8E%E7%9B%B8%E5%AF%B9"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">URL分为绝对与相对</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%8A%82-%E7%BD%91%E9%A1%B5%E4%B8%8B%E8%BD%BD%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">第二节 网页下载的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1 超文本传输协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">HTTP的工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E8%AF%B7%E6%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">HTTP请求结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">HTTP请求方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#HTTP1-0%E5%AE%9A%E4%B9%89%E4%BA%86%E4%B8%89%E7%A7%8D%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">2.2.1.3.1.</span> <span class="toc-text">HTTP1.0定义了三种请求方法：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HTTP1-1%E6%96%B0%E5%A2%9E%E4%BA%865%E7%A7%8D%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">2.2.1.3.2.</span> <span class="toc-text">HTTP1.1新增了5种请求方法：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%A4%B4%E9%83%A8%E7%9A%84%E5%8F%82%E6%95%B0%E5%86%85%E5%AE%B9"><span class="toc-number">2.2.1.4.</span> <span class="toc-text">请求头部的参数内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E5%93%8D%E5%BA%94"><span class="toc-number">2.2.1.5.</span> <span class="toc-text">HTTP响应</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E5%93%8D%E5%BA%94%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.1.6.</span> <span class="toc-text">HTTP响应结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">2.2.1.7.</span> <span class="toc-text">HTTP响应状态码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%A4%B4%E9%83%A8%E7%9A%84%E5%8F%82%E6%95%B0%E5%86%85%E5%AE%B9"><span class="toc-number">2.2.1.7.1.</span> <span class="toc-text">响应头部的参数内容</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%8A%82-%E5%86%85%E5%AE%B9%E8%A7%A3%E6%9E%90%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.3.</span> <span class="toc-text">第三节 内容解析的对象</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/11/01/3D%E5%BB%BA%E6%A8%A1/" title="3D建模"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="3D建模"/></a><div class="content"><a class="title" href="/2021/11/01/3D%E5%BB%BA%E6%A8%A1/" title="3D建模">3D建模</a><time datetime="2021-11-01T06:16:01.000Z" title="发表于 2021-11-01 14:16:01">2021-11-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/23/Python%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%92%8C%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/" title="Python数据采集和网络爬虫"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python数据采集和网络爬虫"/></a><div class="content"><a class="title" href="/2021/09/23/Python%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%92%8C%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/" title="Python数据采集和网络爬虫">Python数据采集和网络爬虫</a><time datetime="2021-09-23T13:04:25.000Z" title="发表于 2021-09-23 21:04:25">2021-09-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/23/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/" title="无题"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2021/09/23/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/" title="无题">无题</a><time datetime="2021-09-23T08:09:51.668Z" title="发表于 2021-09-23 16:09:51">2021-09-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/23/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" title="离散数学"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="离散数学"/></a><div class="content"><a class="title" href="/2021/09/23/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" title="离散数学">离散数学</a><time datetime="2021-09-23T08:07:36.000Z" title="发表于 2021-09-23 16:07:36">2021-09-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/23/English-Speeches-and-Debates/" title="English Speeches and Debates"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="English Speeches and Debates"/></a><div class="content"><a class="title" href="/2021/09/23/English-Speeches-and-Debates/" title="English Speeches and Debates">English Speeches and Debates</a><time datetime="2021-09-23T08:06:53.000Z" title="发表于 2021-09-23 16:06:53">2021-09-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 李泽宇</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>